#!/bin/bash
# **mkocco** is a quick-and-dirty, literate-programming-style documentation
# generator written  in __POSIX shell__ for __Makefile__. It borrows 
# liberally from [shocco][sh], the original shell literate-programming-style 
# doc generator.
#
# `mkocco(1)` reads Makefile scripts and produces annotated source documentation
# in HTML format. Commnets are formatted with Markdown and presented
# alongside syntax highlighted code so as to give an annotation effect.
#
#
# The generated HTML is written to `stdout`.
#
# Usage and Prerequisites
# -----------------------

# The most important line in any shell program
set -e
set -x

# There's a lot of different ways to do usage messages in shell scripts.
# This is my favorite: you write the usage message in a comment --
# typically right after the shebang line -- *BUT*, use a special comment prefix
# like `#/` so that its easy to pull these lines out.
#
# This also illustrates one of mkocco's corner features. Only comment lines
# padded with a space are considered documentation. A `#` followed by any
# other character is considered code.
#
#/ Usage: mkocco [-t <title>] [<source>]
#/ Create literate-programming-style documentation for Makefile.
#/
#/ The mkocco program reads a Makefile from <source> and writes
#/ generated documentation in HTML format to stdout. When <source> is
#/ '-' or not specified, mkocco reads from stdin.

# This is the second part of the usage message technique: `grep` yourself
# for the usage message comment prefix and then cut off the first few
# characters so that everything lines up.
expr -- "$*" : ".*--help" >/dev/null && {
    grep '^#/' <"$0" | cut -c4-
    exit 0
}

usage () {
    echo "Usage:    $0 [options] <source> "
    echo " "
    echo "Options: "
    echo "      -h          show this help message and exit."
    echo "      -t  title   the title"
    echo "      -l  lang    the language"

    exit 0;
}

title="$0"
lang=sh
while getopts "t:l:h" var
do
    case ${var} in
        t)  title="${OPTARG}" ;;
        l)  lang="${OPTARG}" ;;
        h)  usage ;;
        \?) exit 2 ;;
    esac
done
#echo $OPTIND
#echo $*
shift $(($OPTIND - 1))

file=$*
# A custom title may be specified with the `-t` option. We use the filename
# as the title if none is given.
#test "$1" == '-t' && {
#    title="$2"
#    shift;shift
#}


# Next argument should be the `<source>` file. Grab it, and use its basename
# as the title if none was given with the `-t` option
#file="$1"
#: ${title:=$(basename "$file")}

# On GNU systems, csplit doesn't elide empty ifles by default:
CSPLITARGS=$( (csplit --version 2>/dev/null | grep -i gnu >/dev/null) && echo "--elide-empty-files" || true )

# We're going to need a `markdown` command to run comments through. This can
# be [Gruber's `Markdown.pl`][md] (included in the mkocco distribution) or
# Discount's super fast `markdown(1)` in C. Try to figure out if either are
# available and then bail if we can't find anything.
#
# [md]: http://daringfireball.net/projects/markdown/
# [ds]: http://www.pell.portland.or.us/~orc/Code/discount/
command -v "$MARKDOWN" >/dev/null || {
    if command -v Markdown.pl >/dev/null
    then alias markdown='Markdown.pl'
    elif test -f "$(dirname $0)/Markdown.pl"
    then alias markdown="perl $(dirname $0)/Markdown.pl"
    else echo "$(basename $0): markdown command not found." 1>&2
         exit 1
    fi
}

# Work and Cleanup
# ----------------

# Make sure we have a `TMPDIR` set. the `:=` parameter expansion assigns
# the value if `TMPDIR` is unset or null.
: ${TMPDIR:=/tmp}

# Create a temporary directory for doing work. Use `mktemp(1)` if
# available; but, since `mktemp(1)` is not POSIX specified, fallbaok on
# naive temp dir generate using the program's basename and pid.
: ${WORK:=$(
    if command -v mktemp 1>/dev/null 2>&1
    then
        mktemp -d "$TMPDIR/$(basename $0).XXXXXXX"
    else
        dir="$TMPDIR/$(basename $0).$$"
        mkdir "$dir"
        echo "$dir"
    fi
)}

test -z "$WORK" -o "$WORK" = '/' && {
    echo "$(basename $0): could not create a temp work dir"
    exit 1
}

trap "rm -fr $WORK" 0

(cat "$file" && printf "\n\n# \n\n") |

(
    lineno=0
    codebuf=;codehead=
    docsbuf=;docshead=
    while read -r line
    do
        # Issue a warning if the first line of the script is not a shebang
        # line. This can screw things up and wreck our attempt at
        # flip-flopping the two headings.
        lineno=$(( $lineno + 1 ))
        test $lineno = 1 && ! expr "$line" : "#!.*" >/dev/null &&
        echo "$(basename $0): ${file}:1 [warn] shebang! line missing." 1>&2

        # Accumulate comment lines into `$docsbuf` and code lines into
        # `$codebuf`. Only lines matching `/#(?: |$)/` are considered doc
        # lines.
        if expr "$line" : '# ' >/dev/null || test "$line" = "#"
        then docsbuf="$docsbuf$line
"
        else codebuf="$codebuf$line
"
        fi

        # If we have stuff in both `$docsbuf` and `$codebuf`, it means
        # we're at some kind of boundary. If `$codehead` isn't set, we're at
        # the first comment/doc line, so store the buffer to `$codehead` and
        # keep going. If `$codehead` *is* set, we've crossed into another code
        # block and are ready to output both blocks and then straight pipe
        # everything by `exec`'ing `cat`.
        if test -n "$docsbuf" -a -n "$codebuf"
        then
            if test -n "$codehead"
            then docshead="$docsbuf"
                 docsbuf=""
                 printf "%s" "$docshead"
                 printf "%s" "$codehead"
                 echo "$line"
                 exec cat
            else codehead="$codebuf"
                 codebuf=
            fi
        fi
    done

    # We made it to the end of the file without a single comment line, or
    # there was only a single comment block ending the file. Output our
    # docsbuf or a fake comment and then the codebuf or codehead.
    echo "${docsbuf:-#}"
    echo "${codebuf:-"$codehead"}"
)   |

sed -n '
    s/^/:/
    s/^:[   ]\{0,\}# /DOCS /p
    s/^:[   ]\{0,\}#$/DOCS /p
    s/^:/CODE /p
' > "$WORK/raw"
cp ./Markdown.pl  "$WORK"
cd "$WORK"
sed 's/^CODE.*//' < raw |
cat -s  |
sed '
    s/^$/##### DIVIDER/
    s/^DOCS //
' |
perl $(dirname $0)/Markdown.pl |
(
    csplit -sk                               \
           $CSPLITARGS                       \
           -f docs                           \
           -n 4                              \
           - '/<h5>DIVIDER<\/h5>/' '{9999}'  \
           2>/dev/null                      ||
    true
)


# Second Pass: Code Formatting

sed 's/^DOCS.*//' < raw | 
cat -s |
sed '
    s/^$/# DIVIDER/
    s/^CODE //' |
pygmentize -l $lang -f html -O encoding=utf8 |

sed '
    s/<div class="highlight"><pre>//
    s/^<\/pre><\/div>//' |
(
    DIVIDER='/<span class="c"># DIVIDER</span>/'
    csplit -sk                   \
           $CSPLITARGS           \
           -f code               \
           -n 4 -                \
           "$DIVIDER" '{9999}'   \
           2>/dev/null ||
    true
)


layout () {
    cat <<HTML
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv='content-type' content='text/html;charset=utf-8'>
    <title>$1</title>
    <link rel=stylesheet href="https://raw.github.com/datawolf/mkocco/master/mkocco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>$1</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'>$(cat)</td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
HTML
}

# Recombining
# -----------

# Alright, we have separate files for each docs section and separate
# files for each code section. We've defined a function to wrap the
# results in the standard layout. All that's left to do now is put
# everything back together.

# Before starting the pipeline, decide the order in which to present the
# files.  If `code0000` is empty, it should appear first so the remaining
# files are presented `docs0000`, `code0001`, `docs0001`, and so on.  If
# `code0000` is not empty, `docs0000` should appear first so the files
# are presented `docs0000`, `code0000`, `docs0001`, `code0001` and so on.
#
# Ultimately, this means that if `code0000` is empty, the `-r` option
# should not be provided with the final `-k` option group to `sort`(1) in
# the pipeline below.
if stat -c"%s" /dev/null >/dev/null 2>/dev/null ; then
    # GNU stat
    [ "$(stat -c"%s" "code0000")" = 0 ] && sortopt="" || sortopt="r"
else
    # BSD stat
    [ "$(stat -f"%z" "code0000")" = 0 ] && sortopt="" || sortopt="r"
fi

# Start the pipeline with a simple list of split out temp filename. One file
# per line.
ls -1 docs[0-9]* code[0-9]* 2>/dev/null      |
# Now sort the list of files by the *number* first and then by the type. The
# list will look something like this when `sort(1)` is done with it:
#
#     docs0000
#     code0000
#     docs0001
#     code0001
#     docs0002
#     code0002
#     ...

sort -n -k"1.5" -k"1.1$sortopt"             |
# And if we pass those files to `cat(1)` in that order, it concatenates them
# in exactly the way we need. `xargs(1)` reads from `stdin` and passes each
# line of input as a separate argument to the program given.
#
# We could also have written this as:
#
#   ls -1 docs* code* | sort -n -k1.5 -k1.1r  
#
# I like to keep things to a simple flat pipeline when possible, hence the
# `xargs` approach.
xargs cat                   |
# Run a quick substitution on the embedded dividers to turn them into table
# rows and cells. This also wraps each code block in a `<div class=highlight>`
# so that the CSS kicks in properly.
{
    DOCSDIVIDER='<h5>DIVIDER</h5>'
    DOCSREPLACE='</pre></div></td></tr><tr><td class=docs>'
    CODEDIVIDER='<span class="c"># DIVIDER</span>'
    CODEREPLACE='</td><td class=code><div class=highlight><pre>'
    sed "
        s@${DOCSDIVIDER}@${DOCSREPLACE}@
        s@${CODEDIVIDER}@${CODEREPLACE}@
    "
}                                            |
#
# Pipe our recombined HTML into the layout and let it write the result to
# `stdout`.
layout "$title"
#
# More
# ----
#
# **shocco** is the third tool in a growing family of quick-and-dirty,
# literate-programming-style documentation generators:
#
#   * [Docco][do] - The original. Written in CoffeeScript and generates
#     documentation for CoffeeScript, JavaScript, and Ruby.
#   * [Rocco][ro] - A port of Docco to Ruby.
#
# If you like this sort of thing, you may also find interesting Knuth's
# massive body of work on literate programming:
#
#   * [Knuth: Literate Programming][kn]
#   * [Literate Programming on Wikipedia][wi]
#
# [ro]: http://rtomayko.github.com/rocco/
# [do]: http://jashkenas.github.com/docco/
# [kn]: http://www-cs-faculty.stanford.edu/~knuth/lp.html
# [wi]: http://en.wikipedia.org/wiki/Literate_programming
# [sh]: http://rtomayko.github.com/shocco/
#
# Copyright (C) [Ryan Tomayko <tomayko.com/about>](http://tomayko.com/about)<br>
# This is Free Software distributed under the MIT license.
:
